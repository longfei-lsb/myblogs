# MySQL基础之BLGC

[TOC]

## 什么是组提交

> Binary Log Group Commit 即**二进制日志组提交**，MySQL5.6 版本中引进的一个新的特性。

**binlog落盘解释：**MySQL 会将每个事务的操作都记录到 binlog 中，方便我们使用 binlog 来完成复制或者恢复操作。

**binlog落盘关键点：**可是需要调用 `fsync()` 才能将缓存中被更改的 binlog 真正的写到磁盘上，保证数据的持久化。

**binlog落盘分析：**但是这是一个从内存写到磁盘的过程，I/O 比较慢。如果每次事务提交都执行一遍 `fsync()` 将 binlog 持久化落盘到磁盘的话，效率很低。

**binlog落盘解决方案：**于是就想，能不能等几个事务的 binlog 一起调用一次 `fsync()`，一次性落盘。减少 `fsync()` 的次数，从而提高效率。这就是二进制日志组提交的概念。

## 两阶段提交

### 为什么需要？

> 我们需要将写 **binlog 操作**和 **InnoDB 提交操作**通过事务变成原子的，不然kennel出现如下情况：

我们知道：

- **undoLog：**用来回滚还未被提交的数据
- **redoLog：**InnoDB 存储引擎特有的日志，数据库宕机恢复时使用
- **binLog：**它会记录所有存储引擎中事务的操作

在事务提交的时候，我们需要先写入二进制日志，再写 InnoDB 存储引擎的 redo。

在主从复制的环境下，master 提交了一个事务，先写了二进制日志，但是在要写 InnoDB 存储引擎的时候，数据库发生了宕机，此时 binlog 又已经被 slave 接收到了，slave 会执行这个事务，但是实际 master 上并没有这个事务。这就会导致主从数据的不一致。

### 什么是二阶段提交？

> 所谓的二阶段提交就是，我在事务提交的时候，确保先将 binlog 写入，然后再到数据引擎层提交，并且这两个操作是原子的。

**当一个会话中的某一事务 COMMIT 的时候，进入二阶段提交的过程：**

1. 数据库先去协调 Server 层和 Engine，询问是否都可以开始写日志
2. 先把 binlog 写到内存中，然后调用 `fsync()` 将 binlog 从内存写到磁盘上
3. 将真实修改的数据提交到数据库中。当这一步完成才最终返回给会话一个 COMMIT 成功的信号

如果在 `fsync()` 之前数据库 crash 了，重启之后数据将会被回滚，若在 `fsync()` 之后 crash，则会进行重做操作

通过二阶段提交的方式就保证了**存储引擎数据与二进制日志保持一致**。

## 三阶段提交

### 为什么需要？

假设现在有T1、T2、T3 三个事务需要执行，数据在 `fsync()` 之前，三个事务已经写入到了 binlog 中，通过 `fsync()` 操作将 binlog 刷到磁盘。之后先是 T2 COMMIT，将数据更改更新到存储引擎层，接着是 T3 COMMIT，将数据更新到存储引擎层。这时候我们做了一个热备份的操作

**XtraBackup备份原理：**直接拷贝数据库文件，并且记录下当前二进制日志中已经提交的最后一个事务标记。在新的数据库实例上完成 recovery 操作。

**由于热备份的存在，kennel会导致事务写入二进制日志的顺序与事务在存储引擎层提交的顺序不一致**。

为了解决这个问题，MySQL 引入了 `prepare_commit_mutext` 的机制，当事务提交的时候，需要先获得 `prepare_commit_mutext` 这个锁。有了这个锁就可以保证事务写入二进制日志的顺序与事务在存储引擎层提交的顺序一致。

但是这样一来，又变成了串行的，效率又变低了

### 什么是三阶段提交？

> 三阶段提交，顾名思义有三个阶段： Flush 阶段、sync 阶段、commit 阶段。分别对应的就是二进制日志写内存的阶段、二进制日志刷盘的阶段、事务提交到存储引擎层的阶段。

我们Java程序中，控制线程等待的方式，加入等待队列，SQL中也一样：

每个阶段都有 leader、follower 两种角色。

当一个事务进入三个阶段中的某一个阶段，如果发现这个阶段中的队列为空，那么这个事务就会成为 leader 的角色，之后进入同一阶段的事务，发现这个阶段的队列中已经有事务存在了，那就变成 follower 角色。

leader 角色的任务是安排当前阶段队列中的事务按顺序执行，并且带领队列中所有的事务进入下一个阶段。

当 leader 带领队列中的事务进入下一阶段的时候，如果发现下一阶段中已经有事务存在（即下一阶段已有 leader 存在），新来的 leader 自动变成 follower 角色。

三阶段提交在每个阶段都控制了事务的顺序，从而也就控制了事务执行的整体顺序。解决了 `prepare_commit_mutex` 锁导致的问题，事务可以并发的执行。

