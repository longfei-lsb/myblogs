# MySQL面试题

[TOC]

## **UUID与自增主键的区别**

https://www.zhihu.com/question/397289720/answer/2527833019

## 分组横向展示：利用sum与case的方式

https://blog.csdn.net/huhui806/article/details/113558748

## <font size = '4' color = 'pink'>什么是MySQL</font>

## <font size = '4' color = 'pink'>MySQL存储过程与存储函数的区别？</font>

## <font size = '4' color = 'pink'>MySQL的事物怎么实现的？</font>

https://www.cnblogs.com/ttaylor/p/15760737.html

## <font size = '4' color = 'pink'>MySQL事务特性</font>

- **(Atomicity)原子性：**一些列操作要么全部成功，要么全部失败
- **(Consistency)一致性：**数据库总是从一个一致状态变到另一个一致状态(事务修改前后的数据总体保证一致 转账)
- **(Isolation)隔离性：**事务的结果只有提交了其他事务才可见
- **(Durability)持久性：**事务提交后，对数据修改永久的

## <font size = '4' color = 'pink'>MySQL事务隔离级别</font>

事务隔离级别是为了解决多个并行事务竞争导致的数据安全问题的**一种规范**。

总的来说，多个事务竞争可能会导致三种不同的现象：

- 比如A、B两个事务同时在执行，事务A却读取了事务B没有提交到磁盘的数据记录，那么这就是脏读的现象
- 第二个是说，如果事务A在不同时刻读取同一条记录有可能结果会不一样，这就是不可重复读的问题
- 第三个就是说，事务A在执行范围查询或范围修改的时候，事务B插入了一条在事务A范围内的数据，这个时候事务A发现多出了一条数据，或者说发现这条数据并没有被修改，那么看起来像是出现幻觉一样，我们称为幻读

而这三种现象在实际应用里面呢，可能不能接受某些现象的存在，所以SQL标准里面呢，定义了四种隔离级别：

- **读未提交（read uncommitted）:** 事务中的修改，即使没有提交，其他事务也可以看得到（可能会产生：脏读、不可重复读，幻读）
- **读已提交（read committed）:** 事务中的修改只有提交以后才能被其它事务看到（可能产生不可重复读、幻读）
- **可重复读 （repeatable read）：**保证同一事务看到的每行数据结果不同时刻是一致的（可能会产生：幻读）
- **串行化（serializable）：**一个事务执行完了才能执行其它的事务，可以解决所有的并发问题（效率低下）

## <font size = '4' color = 'pink'>MySQL的MVCC机制</font>

**讲一讲没有MVCC会引发的问题：**我们通常需要以事务的方式进行数据库操作，而多个并行事务竞争共享资源时，采用加锁的单一方式来保证数据的原子性和一致性，会极大的降低数据库的性能，所以引入了MVCC机制，目的是提高数据库的并发性能

**讲一讲MVCC的目的：**MVCC 是一种并发控制的方法，InnoDB存储引擎中的快照读是它的一种实现，实现原理主要是通过**`版本链`，`undo日志` ，`Read View `**来实现的。

**讲一讲undoLog日志：**

Undo log 主要用于`记录`数据被`修改之前`的日志，在表信息修改之前先会把数据拷贝到`undo log`里。

当`事务`进行`回滚时`可以通过undo log 里的日志进行`数据还原`。

**讲一讲版本链：**

- MySQL的InnoDB存储引擎在事务进行数据添加\修改操作时，每行数据都会记录undo log日志版本

- 多个版本记录之间，会通过行记录中的数据的隐藏列的回滚指针(roll_pointer)的方式，记录undoLog日志的版本链

**讲一讲读视图Read View：**

在事务进行`快照读`操作的时候会生成`读视图`(Read View)，该快照读是事务执行的快照读的那一刻，生成数据库系统当前的一个事务信息`快照`

其中事务信息有四个属性，分别是：

- `trx_ids`: 当前系统活跃(`未提交`)事务版本号集合。
- `low_limit_id`: 创建当前read view 时“当前系统`最大事务版本号`+1”。
- `up_limit_id`: 创建当前read view 时“系统正处于活跃事务`最小版本号`”
- `creator_trx_id`: 创建当前read view的事务版本号；

我们会根据这四个属性进行数据的非加锁形式的读写隔离操作，来提高数据库的并发性能。

而在这其中呢，要保证数据记录底层的逻辑删除标志、创建事务id的递增性等等细节上也是必要的

## <font size = '4' color = 'pink'>MySQL锁</font>

### <font size = '4' color = 'pink'>锁定义</font>

数据库中，除了使用`latch`保证了传统的计算资源争用以外，**又为了保证其他一些数据的完整性和一致性，而使各种资源在被并发访问时变得有序而设计的一种规则。**而MySQL中的按锁定的颗粒度分为：表级锁、行级锁、页级锁

![image-20220806091436044](https://tva1.sinaimg.cn/large/e6c9d24ely1h4ws1y64i9j20ri0vqmyd.jpg)

### <font size = '4' color = 'pink'>为什么提供了那么多锁？</font>

- `锁机制`为实现`MySQL`的各个隔离级别提供了保证。
- `锁冲突`也是影响数据库并发访问性能的一个重要因素。

所以锁对数据库而言显得尤其重要，也更加复杂

### <font size = '4' color = 'pink'>什么是意向锁？</font>

InnoDB支持多粒度锁，允许行锁与表锁共存，意向锁是为了解决在事务对表进行锁添加时，不必挨个遍历表中每一行来判断是否锁冲突，而提供的一种**表级锁**

意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排 
他锁时的并发性。

**总结来说：**

同一表的表级锁中，由于行锁自动添加到表上的意向锁之间全部兼容

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4x81osuwjj20e805b747.jpg)



但若是要在表上加锁，意向锁与表锁之间需要进行兼容性判断，注意：一下S与X指的是表上的，行上也有，但并非行上的

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4x8c1y5a2j20ii04hq3g.jpg)

**可以这样解释：**

假设一个teacher表，

事务一对id=1的行记录加了X锁，那么表级上会有一个IX锁标记

事务二需要对id=2的行记录加了X锁，因为是行级别锁，所以不会进行表级锁判断，只判断那一行是不是加了其他行锁就好了，加锁成功后，意向锁原本就存在一个IX锁，那么IX锁记录数+1。行级别共享锁同理

事务三需要进行锁表操作，所以需要在表级锁之间进行比对，发现有IX锁，产生表级锁冲突，就会等待。

### <font size = '4' color = 'pink'>什么是自增锁？</font>

当事务向包含 `AUTO_INCREMENT` 列的表中新增数据时，为了保证自增列数据的唯一性，而加的一种表锁

**三个插入场景**

- 简单：提前知道插入数（insert into values(null,sdd)）
- 批量：不知道插入数（insert_select）
- 混合：指定Insert语句中部分行的自增（INSERT INTO teacher (id,name) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d'); ）

**三个锁模式**

- **传统：**对每一条语句挨个竞争AUTO-INC锁。弊端：严重影响并发性能
- **连续：**MySQL 8.0 之前默认的模式，对于提前可知道insert数的来说，就不会使用自增锁，预留空间就好。弊端：提前不知道insert数，还是会去获取自增锁
- **交叉：**去掉了AUTO-INC模式，（通过轻量级的mutex锁为语句分配自增数值的方式）提高了并发性能，多条 `INSERT` 语句可以并发的执行。弊端：对与主从复制会有一些影响

**交叉模式缺陷**

如果 MySQL 采用的格式为 `Statement`，`INSERT` 同时交叉执行，并且 `AUTO_INCREMENT` 交叉分配将会直接导致主从之间同行的数据**主键 ID 不同**。而这对主从同步来说是灾难性的。（**时刻1事务1获得自增值，时刻2事务2获得自增值，以此类推**）

**解决方案：**Binlog 格式从 `Statement` 到 `Row`，或者InnoDB设置默认实现为连续模式，具体看综合性能取舍，前者空间占用更多，后者并发性能低

