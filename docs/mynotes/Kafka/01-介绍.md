# 01-介绍

[TOC]

## 简单说明什么是kafka

举个例子，生产者消费者，生产者生产鸡蛋，消费者消费鸡蛋，生产者生产一个鸡蛋，消费者就消费一个鸡蛋，假设消费者消费鸡蛋的时候噎住了（系统宕机了），生产者还在生产鸡蛋，那新生产的鸡蛋就丢失了。再比如生产者很强劲（大交易量的情况），生产者1秒钟生产100个鸡蛋，消费者1秒钟只能吃50个鸡蛋，那要不了一会，消费者就吃不消了（消息堵塞，最终导致系统超时），消费者拒绝再吃了，”鸡蛋“又丢失了，这个时候我们放个篮子在它们中间，生产出来的鸡蛋都放到篮子里，消费者去篮子里拿鸡蛋，这样鸡蛋就不会丢失了，都在篮子里，而这个篮子就是”kafka“。

鸡蛋其实就是“数据流”，系统之间的交互都是通过“数据流”来传输的（就是tcp、https什么的），也称为报文，也叫“消息”。

消息队列满了，其实就是篮子满了，”鸡蛋“ 放不下了，那赶紧多放几个篮子，其实就是kafka的扩容。

各位现在知道kafka是干什么的了吧，它就是那个"篮子"。

## kafka名词解释

后面大家会看到一些关于kafka的名词，比如topic、producer、consumer、broker，我这边来简单说明一下。

- `producer`：生产者，就是它来生产“鸡蛋”的。
- `consumer`：消费者，生出的“鸡蛋”它来消费。
- `topic`：你把它理解为标签，生产者每生产出来一个鸡蛋就贴上一个标签（topic），消费者可不是谁生产的“鸡蛋”都吃的，这样不同的生产者生产出来的“鸡蛋”，消费者就可以选择性的“吃”了。
- `broker`：就是篮子了。

大家一定要学会抽象的去思考，上面只是属于业务的角度，如果从技术角度，topic标签实际就是队列，生产者把所有“鸡蛋（消息）”都放到对应的队列里了，消费者到指定的队列里取。

## Kafka作为一个分布式的流平台，这到底意味着什么

**关键能力：**

1. 发布订阅
2. 容错(故障转移)的方式存储消息(流)
3. 在消息流发生时处理它们

**几个概念：**

1. kafka支持集群部署
2. 消息是以topic为类别记录的
3. 消息结构（key、value、时间戳）

**四个核心API：**

- 使用 [Producer API](https://www.orchome.com/190)发布消息到topic中
- 使用 [Consumer API](https://www.orchome.com/200) 来订阅topic中的消息
- 使用 [Streams API](https://www.orchome.com/304) 充当一个流处理器，有效地将生产到topic的输入流转换成想要的消费者输出流
- [Connector API](https://www.orchome.com/455) 通过实现连接器（connector），不断地从一些源系统或应用程序中拉取数据到kafka，或从kafka提交数据到宿系统（sink system）或应用程序

## 基本术语

#### Topic

Kafka将消息分门别类，每一类的消息称之为一个主题（Topic）。

#### Producer

发布消息的对象称之为主题生产者（Kafka topic producer）

#### Consumer

订阅消息并处理发布的消息的对象称之为主题消费者（consumers）

#### Broker

已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理（Broker）。 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。

## 主题和日志 （Topic和Log）

topic 只是消息的分属类别名，一个分属类别下可以有0-n个消费者订阅 该topic下的消息

对于每个 topic，Kafka 集群都会维护一个分区log（所谓分区log，即：一个topic有多个log，每个log其实就是一个顺序的不可变的消息队列），就像下图中所示：

![KmCudlf7DsaAVF0WAABMe0J0lv4158](https://img.orchome.com/group1/M00/00/01/KmCudlf7DsaAVF0WAABMe0J0lv4158.png)

一个分区中的每个消息都被分了一个唯一序列号，称之为偏移量（offset）

Kafka集群保持所有的消息，直到它们过期（无论消息是否被消费），消费者可以用 offset 来控制读取消息开始的位置，这种设计对消费者来说操作自如，一个消费者的操作不会影响其它消费者对此log的处理

![img](https://pics3.baidu.com/feed/d1a20cf431adcbef5d4b13e77e9230d4a2cc9f9e.jpeg@f_auto?token=280ce97387562ae8b21200cf9f88d822)

**分区设计的优势：**

- 可以处理更多的消息，不受单台服务器的限制
- 分区可以作为并行处理的单元，稍后会谈到这一点

## 分布式(Distribution)

Log的分区被分布到集群中的多个服务器上。每个服务器处理它分到的分区。 根据配置每个分区还可以复制到其它服务器作为备份容错。

每个分区有一个leader，零或多个follower。Leader处理此分区的所有的读写请求，而follower被动的复制数据。如果leader宕机，其它的一个follower会被推举为新的leader。 

一台服务器可能同时是一个分区的leader，另一个分区的follower。 这样可以平衡负载，避免所有的请求都只让一台或者某几台服务器处理。

## Geo-Replication(异地数据同步技术)

Kafka MirrorMaker为群集提供`geo-replication`支持。借助`MirrorMaker`，消息可以跨多个数据中心或云区域进行复制。 您可以在active/passive场景中用于备份和恢复; 或者在active/passive方案中将数据置于更接近用户的位置，或数据本地化。

## 生产者(Producers)

生产者往某个Topic上发布消息。生产者也负责选择发布到Topic上的哪一个分区。最简单的方式从分区列表中轮流选择。也可以根据某种算法依照权重选择分区。开发者负责如何选择分区的算法。

## 消费者(Consumers)

正常情况下，消息模型分为两种：队列和发布订阅式。队列的处理方式中，一条消息只能一个消费者消费；发布订阅中，一条消息可以广播给所有订阅的消费者。kafka一共了一个消费者组的概念来综合这两个消费模型。原理是：1-n个消费者（consumer）绑定一个消费者组（consumer group），一条消息广播到所有订阅的消费者组，但是这条消息传达到组内后，只能由组内一个消费者消费掉

![KmCudlf7D-OAEjy8AABoxGLnMI4173](https://img.orchome.com/group1/M00/00/01/KmCudlf7D-OAEjy8AABoxGLnMI4173.png)

## Kafka的保证(Guarantees)

- 生产者发送到一个特定的Topic的分区上，消息将会按照它们发送的顺序依次加入，M1先发送，那么M1将比M2的offset低，并且优先的出现在日志中
- 消费者收到的消息也是此顺序（队列的特性：先进先出嘛）
- 如果一个Topic配置了复制因子（replication factor）为N， 那么可以允许N-1服务器宕机而不丢失任何已经提交（committed）的消息。

## kafka作为一个消息系统

**Kafka的流与传统企业消息系统相比的概念如何？**

通过消费者组的概念集合传统的两种消费模式：`队列`、`发布订阅`

`队列`：消费者组（consumer group）允许同名的消费者组成员瓜分处理

`发布订阅`：允许你广播消息给多个消费者组（不同名）

**kafka有比传统的消息系统更强的顺序保证。**

**传统队列模型中：**尽管保证了一个消息只能一个消费者消费，但订阅队列的多个消费者之间不存在同步关系，就会导致消费乱序，通常的解决办法就是：一个对列只能一个消费者订阅消费

**kafka中：**采用的是topic的分区概念，每个partition仅由同一个消费者组中的一个消费者消费到，每个topic有多个分区，则需要对多个消费者做负载均衡。但请注意，消费者的数量并不能决定一个Topic的并行度。它是由分区的数目决定的。`相同的消费者组中不能有比分区更多的消费者，否则多出的消费者一直处于空等待，不会收到消息，例子如下：`



![img](https://pics7.baidu.com/feed/2fdda3cc7cd98d10c65bfb7bf202a6077aec90b0.jpeg@f_auto?token=7c80c2562c22a0b99435e450a1889bbd)

## kafka作为一个存储系统

Kafka比别的系统的优势是它是一个非常高性能的`存储系统`。

你还可以认为kafka是一种专用于高性能，低延迟，提交日志存储，复制，和传播特殊用途的`分布式文件系统`。

## kafka的流处理

仅仅读，写和存储是不够的，kafka的目标是实时的流处理。

流处理持续获取`输入topic`的数据，进行处理加工，然后写入`输出topic`。例如，一个零售APP，接收销售和出货的`输入流`，统计数量或调整价格后输出。