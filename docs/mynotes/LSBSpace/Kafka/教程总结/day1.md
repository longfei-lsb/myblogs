**为何引入Kafka，有什么作用？**

- **缓冲：**client 端以 300m/s 的数据量向接收速率为 100m/s 的服务端发送数据，会存在阻塞，所以中间加一个Kafka类似于缓存层，将client数据接收的同时，以一定速率去向服务器发送消息
- **消峰：**同上
- **解耦：**我们对于每个消息可能会有多个业务去处理，语法也会不一样，这个时候Kafka类似于一个统一的接口层，将消息统一放到Kafka中，这样无论客户端还是服务端只需要针对Kafka接口层做一次对接，再利用Kafka的发布订阅/模式，由接收放自主对接就好了
- **异步通信：**有些不影响主流程的逻辑，又很耗时的话，我们可以采用Kafka去慢慢处理

**Kafka的定义**

- **起初：**作为通信消息队列
- **后来：**作为数据集成、数据处理、数据分析的平台，不仅仅只是通信队列了

**Kafka的模式**

- **点对点：**producer 发送消息到 Kafka，consumer 接收到消息响应消息ack，kafka收到ack成功后删除消息
- **发布/订阅：**引入topic的概念，可以创建不同主题，发送不同类型的消息，consumer 根据自己需要订阅对应主题的消息进行消费
  - 如果消息体量过大，可以将topic改为创建多个分区的模式，为了高可用性，也可以给每个分区创建多个副本
  - 消费后不删除消息

**两者区别：**

前者删除消息、后者不删除；

前者单结点，后者一个分区对应一个结点

前者对应一个消费者，无消费者组的概念，后者每个消费者对应一个消费者组，每个分区只能对应组内一个消费者消费，而每个消费者可以消费多个分区

如果消费者挂了，组内会进行重新分配，会重新分配分区

**Kafka的结构**

producer发送消息 --> interceptor(拦截器) --> 自己的序列化器(Serializer) --> 分区器（Partitioner）--> 异步放入 RecordAccumulator[DQueue1,……,DQueuen(默认batch.size=16kb)]（默认32m），RecordAccumulator在缓存池中，并且每个分区都有一个DQueue --> 当条件达到batch.size（默认16kb） 或 linger.ms（默认0） 后，Sender线程读取数据，放入InFlightRequests中，默认每个broker节点（服务器）维护一个队列，并且最多放入五个请求，在通过Selestor发送到集群中

![img](https://img0.baidu.com/it/u=2409676723,4201193548&fm=253&fmt=auto&app=138&f=JPEG?w=959&h=500)

**producer 到 集群时候，集群可配置的ack回应规则：**

- **0：**生产者发送过来就不管了，可靠性差，效率高

- **1：**生产者发送过来数据Leader应答，可靠性中等，效率中等

- **-1：**生产者发送过来数据Leader应答以及ISR队列里面所有Follow应答，可靠性高，效率低

- **生产环境下如何配置：**0，很少用；1，一般传输普通日志，比如获取用户行为数据，丢失一些无所谓；2，传输跟钱相关的数据，对可靠性要求比较高的场景

- **数据重复分析：** -1时，生产者发送过来数据，Leader以及ISR中Follow收齐数据后应答

  - 收齐瞬间，Leader准备应答，应答失败，重选Follow称为新Leader，producer发送消息失败重试，此时新Leader接收的消息，与旧Leader同步的那个数据是相同的数据，**导致数据重复**
  - **解决方案？****幂等性**：同一条消息在一个分区中只能有一个
    - **如何做到？**开启幂等性--》**enable.idempotence=true**
    - **解决方案原理？**当 producer 发送消息到集群时，集群会给每个消息提供附加信息（PID：集群的ID，每重启一次就会有变动；seq：消息在分区中的序列号；partition：分区号）作为key，这样如果集群判断出来分区存在相同的key就不会进行存储了
    - **如果Kafka重启了，导致PID更新了，数据还会导致重复，怎么办？**
      - **解决方案？**添加事务

  ![img](https://img-blog.csdnimg.cn/img_convert/e7cbb1fa758ebfc232407c5ef915b939.png)

**乱序的出现：**

当五个请求中间有一个请求ack失败，就会重新重试，而重试的过程中后面的请求先进行了发送，就会**导致消息消费乱序**

	- **Kafka如何保证顺序的**：到五个请求都返回成功，排一遍顺序，再给消费者

**什么是ISR？**

类似于副本的东西，但不是副本，当我们ack配置为-1的时候，我们需要Leader将信息最终同步到副本，但是如果有副本出现异常，就会导致效率及其低下，**为了保证效率，Kafka在Zookeeper中提供了ISR这个东西**，只要ISR中的Follow接收并回应了Leader，Leader就认为可以向producer回应消息已经接收并同步给力副本，**同时ISR提供类似于心跳机制**的东西，如果副本没有回应，那么就会从ISR的Follow中移除

**Zookeeper需要了解的信息：**

- **存储信息：**Kafka实例创建后，就会将地址、分区、副本信息保存在Zookeeper中，并指定每个Topic的Leader以及副本分区在哪里
- **提供leader选举功能：**Kafka集群中，每个topic的每个分区都提供controller节点，谁先注册到Zookeeper，谁占据成功controller，然后监听Brokers（服务器分区）都变化，进行leader选举，controller将节点信息上传到zk，其他节点从zk同步相关信息，在出现情况时，controller监听到节点变化，获取ISR，进行选举，更新ISR
- **选举规则：**以在ISR中存活为前提，轮训AR分配Leader

![img](https://pics6.baidu.com/feed/aa64034f78f0f736e445802537b7c515eac4134d.jpeg@f_auto?token=b9e0e42ebffa37a18b3b709d13882d91)