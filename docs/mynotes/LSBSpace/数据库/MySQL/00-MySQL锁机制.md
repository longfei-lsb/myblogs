# MySQL锁机制

[TOC]

## 概述

数据库锁定机制简单的来说，就是数据库为了保证数据的一致性与完整性，而使各种共享资源在被并发访问时变得有序所设计的一种规则。

- `锁机制`为实现`MySQL`的各个隔离级别提供了保证。
- `锁冲突`也是影响数据库并发访问性能的一个重要因素。

所以锁对数据库而言显得尤其重要，也更加复杂

MySQL数据库根据锁锁定数据的颗粒度可分为表级锁、行级锁和页级锁。

## 数据库并发场景

- `读-读`：不存在任何问题，也不需要并发控制
- `读-写`：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读
- `写-写`：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失

**ps**

- **第一类更新丢失：**事务T2撤销时，撤销了事务T1已经更新的数据
- **第二类更新丢失：**多个事务查询相同的记录，然后各自基于查询的结果更新记录时会造成第二类丢失更新问题

## 并发问题的解决方案

- **MVCC：**读操作利用多版本并发控制，写操作进行加锁  。
- **加锁：**读、写操作都采用  加锁  的方式。

**`MVCC` vs `lock`**

读-写场景中，`MVCC`采用快照读提高并发行能， `lock`采用排队，影响性能

写-写场景中，存在第一类更新丢失，第二类更新丢失。必须采用`lock`方式

## 锁的不同角度分类

![image-20220806091436044](https://tva1.sinaimg.cn/large/e6c9d24ely1h4ws1y64i9j20ri0vqmyd.jpg)

### **数据操作的类型划分（表锁X\S｜行锁X\s）**

- **读锁：**也称为共享锁、英文用`S`表示。同一份数据，多个事务读操作可以同时进行不会阻塞影响
- **写锁：**也称为排他锁、英文用`X`表示。当前写操作没有完成前，它会阻断其他写锁和读锁

**ps：**对于  InnoDB 引擎来说，**<font color= 'pink'>读锁和写锁可以加在表上，也可以加在行上</font>**。

### 数据操作的粒度划分

> 表级锁、页级锁、行锁

#### 表锁

- `LOCK TABLES t READ `,InnoDB存储引擎会对表 t 加表级别的`S`锁 
- `LOCK TABLES t WRITE `,InnoDB存储引擎会对表 t 加表级别的`X`锁 

尽量不要加表锁，它们并不会提供什么额外的保护，只是会降低并发能力而已，InnoDB的厉害之处还是实现了更细粒度的行锁  

##### 意向锁 （intention lock）

> InnoDB支持多粒度锁，允许行锁与表锁共存。
>
> 意向锁是为了**解决**在事务对表进行锁添加时，不必挨个遍历表中每一行来判断是否锁冲突，而提供的一种不需要用户干预，InnoDB自动添加的**表级锁**。它提高了数据库的性能
>
> 意向锁不会与行级的共享 / 排他锁互斥！正因为如此，意向锁并不会影响到多个事务对不同数据行加排 
> 他锁时的并发性。

- **意向共享锁 （intention shared lock, IS）：**事务有意向对表中的某些行加共享锁 （S锁）

```sql
-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。 
SELECT column FROM table ... LOCK IN SHARE M
```

- **意向排他锁 （intention exclusive lock, IX）：**事务有意向对表中

```sql
-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。 
SELECT column FROM table ... FOR UPDATE;
```

**总结来说：**

同一表的表级锁中，由于行锁自动添加到表上的意向锁之间全部兼容

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4x81osuwjj20e805b747.jpg)



但若是要在表上加锁，意向锁与表锁之间需要进行兼容性判断，注意：一下S与X指的是表上的，行上也有，但并非行上的

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4x8c1y5a2j20ii04hq3g.jpg)

**可以这样解释：**

假设一个teacher表，

事务一对id=1的行记录加了X锁，那么表级上会有一个IX锁标记

事务二需要对id=2的行记录加了X锁，因为是行级别锁，所以不会进行表级锁判断，只判断那一行是不是加了其他行锁就好了，加锁成功后，意向锁原本就存在一个IX锁，那么IX锁记录数+1。行级别共享锁同理

事务三需要进行锁表操作，所以需要在表级锁之间进行比对，发现有IX锁，产生表级锁冲突，就会等待。

##### 自增锁（AUTO-INC锁）

> 自增锁的本质是**表锁**，较为特殊。当事务 A 向包含了 `AUTO_INCREMENT` 列的表中新增数据时，为了保证自增列数据的唯一性，就会持有自增锁

###### **插入场景**

- **简单插入：**当语句被初始处理时，已经确定要插入的行数
  - INSERT...VALUES() 
- **批量插入：**事先不知道要插入的行数 （和所需自动递增值的数量）的语句
  - INSERT ... SELECT ， REPLACE ... SELECT 和 LOAD DATA 
- **混合模式插入：**这些是“Simple inserts”语句但是指定部分新行的自动递增值。
  - INSERT INTO teacher (id,name) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d'); 
  - INSERT ... ON DUPLICATE KEY UPDATE 

###### **锁模式**

针对InnoDB提供了**锁模式**来应对不同的插入场景

- 传统模式（Traditional）
- 连续模式（Consecutive）
- 交叉模式（Interleaved）

分别对应配置项 `innodb_autoinc_lock_mode` 的值0、1、2.

***ps：**在 MySQL 8.0 之前，InnoDB 锁模式默认为**连续模式**，值为1，而在 MySQL 8.0 之后，默认模式变成了**交叉模式**。至于为啥会改变默认模式，后面会讲。*



**传统模式**

> 说白了就是还没有**锁模式**这个概念时，InnoDB 的自增锁运行的模式。只是后面版本更新，InnoDB 引入了**锁模式**的概念，然后 InnoDB 给了这种以前默认的模式一个名字，叫——传统模式。

当我们向包含了 `AUTO_INCREMENT` 列的表中插入数据时，都会持有这么一个特殊的表锁——自增锁（AUTO-INC），并且当语句执行完之后就会释放，这样一来可以保证单个语句内生成的自增值是**连续**的。

**弊端：**`AUTO-INC`的存在会使得 MySQL 的性能略有下降，因为同时只能执行一条 `INSERT` 语句



**连续模式**

> MySQL 8.0 之前默认的模式，之所以提出这种模式，是因为传统模式存在影响性能的弊端，所以才有了连续模式

连续模式下，简单插入则可以不用获取自增锁，直接把这个 `INSERT` 语句所需要的空间流出来，就可以继续执行下一个语句了

> 当然，这里其实并非什么锁也不用。在实际分配 ID 的过程中，InnoDB 会使用较为轻量级的 mutex 锁，来防止 ID 重复分配，ID 一旦分配好了，mutex 锁就会被释放。

但是如果 `INSERT` 语句不能提前确认数据量，则还是会去获取自增锁。这样一来，多条 `INSERT` 语句可以并发的执行，这也是三种锁模式中扩展性最好的一种。



**交叉模式**

所有插入场景都不会使用到`AUTO-INC`自增锁，而是使用较为轻量的 `mutex` 锁

这样一来，多条 `INSERT` 语句可以并发的执行，这也是三种锁模式中扩展性最好的一种

对于简单插入场景来说，可以保证连续，

但对于其他场景并发执行所带来的副作用就是单个 `INSERT` 的自增值并不连续，因为 `AUTO_INCREMENT` 的值分配会在多个 `INSERT` 语句中来回交叉的执行。例如；**时刻1事务1获得自增值，时刻2事务2获得自增值，以此类推**

**优点很明确，提高了并发性能。缺点是在并发的情况下无法保证数据一致性**



**交叉模式缺陷**

要了解缺陷是什么，还得先了解一下 MySQL 的 BinlogBinlog 一般用于 MySQL 的**数据复制**，通俗一点就是用于主从同步。Binlog 的格式有 3 种：

- **Statement** 基于语句，只记录对数据做了修改的SQL语句
- **Row** 只记录被修改的行，所以Row记录的binlog日志量一般来说会比Statement格式要多。基于Row的binlog日志非常完整、清晰，记录了所有数据的变动
- **Mixed** Statement和Row的结合，怎么个结合法呢。例如像`alter table`之类的对表结构的修改，采用Statement格式。其余的对数据的修改例如`update`和`delete`采用Row格式进行记录

如果 MySQL 采用的格式为 `Statement` ，记录语句的方式进行同步。那么并发情况下 `INSERT` 语句的执行顺序就无法得到保障，从而导致同一事务中SQL语句执行完毕后生成的ID与同步到从服务器相同语句执行后生成的ID不一致。**主键 ID 不同**。而这对主从同步来说是灾难性的。

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4xb03uu2gj21400fd75n.jpg)

而后来，基于 MySQL 默认 Binlog 格式从 `Statement` 到 `Row` 的变更，InnoDB 也将其自增锁的默认实现从连续模式，更换到了效率更高的**交叉模式**。主从之间同步的就是真实的行数据了，而且 `主键ID` 在同步到从库之前已经确定了，就对同步语句的顺序并不敏感，就规避了上面 `Statement` 的问题。

**总结**

你可能会说，为啥要了解这么深？有啥用？

其实还真有，例如在业务中你有一个需要执行 几十秒 的脚本，脚本中不停的调用多次 `INSERT`，这时就问你这个问题，在这几十秒里，会阻塞其他的用户使用对应的功能吗？

如果你对自增锁有足够的了解，那么这个问题将会迎刃而解。

##### 元数据锁（MDL锁）

> MySQL5.5引入了meta data lock，简称MDL锁。

表锁、保证读写正确性

例如：如果一个线程遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更 ，查询线程拿到的结果跟表结构对不上，这肯定是不行的

因此， **当对一个表做增删改查操作的时候，加  MDL读锁；当要对表做结构变更操作的时候，加 MDL 写** 
**锁。**

#### 行锁



##### 记录锁（Record Locks）

> S型记录锁  和  X型记录锁，除了加锁粒度不同以外，与表锁记录规则



##### 间隙锁（Gap Locks）

> 间隙锁：又称gap锁， **只存在于RR**级别之下，**仅仅为解决幻影问题而生**的一种**行锁**

基于：**非唯一索引**与**临键算法**

请务必牢记：**使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据**。

**间隙锁设置**

```sql
# 默认值为OFF
show variables like 'innodb_locks_unsafe_for_binlog';
```

MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种：

- 使用 MVCC 方案解决
- 采用 加锁 方案解决

**间隙锁规则**

**范围区间：**左开右开

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4xy95s29cj20mw03w74l.jpg)

**唯一索引：**只会加记录锁

**普通索引：**不管是何种查询，只要加锁，都会产生间隙锁

**产生死锁（缺陷）**

事务T1拿到id为[5,9)之间的间隙锁后，去插入/更新[20,30)，而事务T2在事务T1插入/更新之前，已经在[20，30)间隙上加了锁，这时如果事务T2再在[5,9)之间去插入/更新，那么就会报错



##### 临键锁（Next-Key Locks）

> Next-Key 可以理解为一种**间隙锁**与**记录锁**的合并，也可以理解为一种特殊的**算法**。
>
> 通过**临建锁**可以解决`幻读`的问题。

**范围区间：**左开右闭

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4y2qnr2zoj20n503rjrp.jpg)

**规则：**每个数据行上的`非唯一索引列`上都会存在一把**临键锁**

**ps：**需要强调的一点是，`InnoDB` 中`行级锁`是基于索引实现的，**临键锁**只与`非唯一索引列`有关，在`唯一索引列`（包括`主键列`）上不存在**临键锁**。

##### 间隙锁 VS 临键锁

1. **InnoDB** 中的`行锁`的实现依赖于`索引`，一旦某个加锁操作没有使用到索引，那么该锁就会退化为`表锁`。
2. **记录锁**存在于包括`主键索引`在内的`唯一索引`中，锁定单条索引记录。
3. **间隙锁**存在于`非唯一索引`中，锁定`开区间`范围内的一段间隔，它是基于**临键锁**实现的。
4. **临键锁**存在于`非唯一索引`中，该类型的每条记录的索引上都存在这种锁，锁定一段`左开右闭`的索引区间，它是一种特殊的**间隙锁**。

##### 插入意向锁（Insert Intention Locks）

> 插入意向锁是在插入一条记录行前，由`INSERT` 操作产生的**一种间隙锁**。
>
> InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构 ，表明有事务想在某个间隙中插入新记录，但是现在在等待。该锁用以表示事务具有**插入意向**

在讲解之前，先来思考一个问题——假设有用户表结构如下：

**MySql**，**InnoDB**，**Repeatable-Read**：users(id PK, name, age KEY)

| id   | name | age  |
| ---- | ---- | ---- |
| 1    | Mike | 10   |
| 2    | Jone | 20   |
| 3    | Tony | 30   |

首先`事务 A` 插入了一行数据，并且没有 `commit`：

```sql
INSERT INTO users SELECT 4, 'Bill', 15;
复制代码
```

随后`事务 B` 试图插入一行数据：

```sql
INSERT INTO users SELECT 5, 'Louis', 16;
复制代码
```

请问：

1. 使用了什么锁？
2. `事务 B` 是否会被`事务 A` 阻塞？

首先让我们来看一下 [MySql 手册](https://link.juejin.cn?target=https%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F8.0%2Fen%2Finnodb-locking.html%23innodb-insert-intention-locks) 是如何解释 **InnoDB** 中的`插入意向锁`的：

> An insert intention lock is a type of gap lock set by INSERT operations prior to row insertion. This lock signals the intent to insert in such a way that multiple transactions inserting into the same index gap need not wait for each other if they are not inserting at the same position within the gap. Suppose that there are index records with values of 4 and 7. Separate transactions that attempt to insert values of 5 and 6, respectively, each lock the gap between 4 and 7 with insert intention locks prior to obtaining the exclusive lock on the inserted row, but do not block each other because the rows are nonconflicting.

`插入意向锁`是在插入一条记录行前，由 **INSERT** 操作产生的一种`间隙锁`。该锁用以表示插入**意向**，当多个事务在**同一区间**（gap）插入**位置不同**的多条数据时，事务之间**不需要互相等待**。假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的`间隙锁`，但是因为数据行之间并不冲突，所以两个事务之间并**不会产生冲突**（阻塞等待）。

总结来说，`插入意向锁`的特性可以分成两部分：

1. `插入意向锁`是一种特殊的`间隙锁`  —— `间隙锁`可以锁定**开区间**内的部分记录。
2. `插入意向锁`之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（`主键`、`唯一索引`）不冲突，那么事务之间就不会出现**冲突等待**。

需要强调的是，虽然`插入意向锁`中含有`意向锁`三个字，但是它并不属于`意向锁`而属于`间隙锁`，因为`意向锁`是**表锁**而`插入意向锁`是**行锁**。

现在我们可以回答开头的问题了：

1. 使用`插入意向锁`与`记录锁`。
2. `事务 A` 不会阻塞`事务 B`。

**为什么不用间隙锁？**

如果只是使用普通的`间隙锁`会怎么样呢？还是使用我们文章开头的数据表为例：

MySql，InnoDB，Repeatable-Read：users(id PK, name, age KEY)

| id   | name | age  |
| ---- | ---- | ---- |
| 1    | Mike | 10   |
| 2    | Jone | 20   |
| 3    | Tony | 30   |

首先`事务 A` 插入了一行数据，并且没有 `commit`：

```sql
INSERT INTO users SELECT 4, 'Bill', 15;
复制代码
```

此时 `users` 表中存在**三把锁**：

1. id 为 4 的记录行的`记录锁`。
2. age 区间在（10，15）的`间隙锁`。
3. age 区间在（15，20）的`间隙锁`。

最终，`事务 A` 插入了该行数据，并锁住了（10，20）这个区间。

随后`事务 B` 试图插入一行数据：

```sql
INSERT INTO users SELECT 5, 'Louis', 16;
复制代码
```

因为 16 位于（15，20）区间内，而该区间内又存在一把`间隙锁`，所以`事务 B` 别说想申请自己的`间隙锁`了，它甚至不能获取该行的`记录锁`，自然只能乖乖的等待 `事务 A` 结束，才能执行插入操作。

很明显，这样做事务之间将会频发陷入**阻塞等待**，**插入的并发性**非常之差。这时如果我们再去回想我们刚刚讲过的`插入意向锁`，就不难发现它是如何优雅的解决了**并发插入**的问题。

**总结**

1. **MySql InnoDB** 在 `Repeatable-Read` 的事务隔离级别下，使用`插入意向锁`来控制和**解决并发插入**。
2. `插入意向锁`是一种特殊的`间隙锁`，而意向锁是一种表锁。
3. `插入意向锁`在**锁定区间相同**但**记录行本身不冲突**的情况下**互不排斥**。

#### 页锁

> 是一种比行锁**锁定更多数据资源**的（因为一个页中可以有多个行记录），在**页粒度**上，开销 
> **介于表锁和行锁之间**的一种锁机制

每个层级的锁数量是有限制的，因为锁会占用内存空间， 锁空间的大小是有限的。

当某个层级的锁数量超过了这个层级的阈值时，就会进行`锁升级`

锁升级就是用更大粒度的锁替代多个更小粒度的锁，好处是占用的锁空间降低了，但同时数据的并发度也下降了。

### 锁的态度划分

> 乐观锁、悲观锁

#### 悲观锁

悲观锁是一种思想，悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（**for update**）

#### 乐观锁

乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新 
的时候会判断一下在此期间别人有没有去更新这个数据，也就是 不采用数据库自身的锁机制，**而是通过** 
**程序来实现**

**实现方式：** 

- **版本号机制：**UPDATE ... SET version=version+1 WHERE version=version
- **CAS机制：**乐观锁就是程序员自己控制数据并发操作的权限

**使用场景**

乐观锁适用读多写少没，悲观锁适用读少写多

### 加锁方式划分

![image-20220809184726972](https://tva1.sinaimg.cn/large/e6c9d24ely1h50pguig4lj21au0rs0wa.jpg)
