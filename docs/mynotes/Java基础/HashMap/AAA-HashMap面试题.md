# HashMap面试题

[TOC]

## **<font size = '4' color = 'pink'>二倍扩容</font>**

二倍扩容就是对数组的迁移

### **<font size = '4' color = 'pink'>二倍扩容的作用？</font>**

- **减少hash碰撞**
- **尽可能的减少元素位置的移动**

## **<font size = '4' color = 'pink'>描述一下put操作流程？</font>**

**插入操作**

1. 是否需要扩容
2. 索引位置是否有值
3. 是否超过扩容阈值（容量*扩容因子）
4. 节点插入后的回调（例如：链表Map插入节点后删除最老的节点）

**更新操作**

1. 判断索引位置有值
2. 判断hash相等，key相等==》更新返回原值
3. 否则，如果是树节点，就调用`putTreeVal`
4. 否则，链表方式开始尾部插入
5. 若链表长度大于8，数组长度不大于64，则转化为红黑树，否则数组扩容

## **<font size = '4' color = 'pink'>你心中是否有树？</font>**

### 二叉树

- 节点的左子树小于节点本身
- 节点的右子树大于节点本身
- 左右子树同样为二叉搜索树

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4vnqu88vrj205e07l74a.jpg)

典型的大长腿瘸子，影响性能。最坏的查询效率是O(n)，其中n是树中的节点个数

### 平衡二叉查找树（AVL）

任一节点对应的两棵子树的最大高度差（平衡因子）为 1

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4vo5l2rufj20lr07tmxz.jpg)

AVL树把最坏情况的复杂度控制在可接受范围

### m 阶的B树

**平衡因子 = 0：**所有的叶子节点都在同一层

**每个节点最多有 m 个子节点：**不用像 AVL 树那样为了保持平衡频繁的旋转节点

**多路特性：**降低树的高度，查找频次；显得矮胖很多

https://segmentfault.com/a/1190000020416577

### B+ 树

与B 树类似，但：

- 叶子节点存放数据，非叶子节点存放索引
- 叶子结点本身依关键字的大小自小而大顺序链接
- 父节点存有右孩子的第一个元素的索引

### 红黑树

1. 节点是红色或黑色
2. 根是黑色
3. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点
4. 每个红色节点必须有两个黑色的子节点（不能有两个连续的红色节点）

![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4vp3ihfd1j20d8086aal.jpg)

- 红黑树插入删除时间要比AVL快，红黑树不要求有不严格的平衡性控制，减少了为了达到平衡而进行的旋转操作次数
- 红黑树的特点，使得任何不平衡都会在三次旋转之内解决
- 查找操作，AVL树的效率更高，因为AVL平衡

### **<font size = '4' color = 'pink'>ConcurrentHashMap如何保证安全以及扩容</font>**

- 利用`CAS`的方式去新增节点
- 利用`synchronized`的方式去更新节点值

**扩容**

> 实现方式是，将表拆分，让每个线程处理自己的区间



![img](https://tva1.sinaimg.cn/large/e6c9d24ely1h4vtkigd5ej213s0c2ab6.jpg)

